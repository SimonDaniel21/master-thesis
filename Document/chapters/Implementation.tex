\chapter{Implementation}
\label{ch:implementation}


\section{Prgram Syntax}

Choreo (Multiparty Program) P -> if E then P else P endif P
\newline| send_receive 		:v@l <= v@l2
\newline| compute      		: v@l <= E@l
\newline| choreo 			: v@l <= CHOREO with mapping P END_CHOREO P
\newline| end 				: v@l

Expression E -> Variable: v
\newline| CONSTANT : c
\newline| PLUS     : (E+E)
\newline| DIVIDE   : (E/E)
\newline| Function -> f(E)

v sind Variablennamen (Strings) und l Location Namen (Strings)

\begin{grammar}
<Choreo> ::= <ident> ‘=’ <expr>
\alt ‘for’ <ident> ‘=’ <expr> ‘to’ <expr> ‘do’ <statement>
\alt ‘{’ <stat-list> ‘}’
\alt <empty>
<stat-list> ::= <statement> ‘;’ <stat-list> | <statement>
\end{grammar}


\begin{grammar}
<Choreo> ::= <ident> ‘=’ <expr>
\alt ‘for’ <ident> ‘=’ <expr> ‘to’ <expr> ‘do’ <statement>
\alt ‘{’ <stat-list> ‘}’
\alt <empty>
<stat-list> ::= <statement> ‘;’ <stat-list> | <statement>
\end{grammar}

\section{Networking in Lean4}
Lean4's standard Library provides IO operations for exchanging values between multiple Threads. While this would suffice to test the functionality of running Choreographies on a single machine, it is much more desirable to be able to split the Choreography into actual seperate programs that may run on different machines. To accomplish this I decided to implement message exchanging by Sockets.
While some PLs like Java provide a Language embedded implementation of Sockets, or other well established Languages like Haskell provide mature Librarays for a Socket API, Lean has a much younger ecosystem that seems less feature rich. The Solution i chose is the relatively young Lean4 library 'sockets for Lean 4' by Henrik Böving (TODO in Quellen reinpacken) which is hosted at https://github.com/hargoniX/socket.lean under the MIT License. It servers as a wrapper around the platform specific 'winsock.h' Windows, and the 'sys/socket.h' Unix C-librarys while providing a clean Lean interface.
\par
To abstract away the Socket setup code in my local programs i decided to reopen a new socket for every communication operation in the Choreography for simplicity

\begin{lstlisting}[language=lean]
def address.send (a: address) (msg: t) [Serialize t]: IO Unit := do
  let bytes := Serialize.to_bytes msg
  let sock ← Socket.mk .inet .stream
  sock.connect a
  let sz ← sock.send bytes
  sock.close
\end{lstlisting}

similiarly to the sock.connect operation, the 'receive' function will bind an listen to a socket with the corresponding addres. For convenience a 'broadcast' function is also available, that takes an 'List address' instead of a single address and sends msg to all addresses in the List.
\newline
Serialize is a simple TypeClass that provides the following two functions:
\begin{lstlisting}[language=lean]
class Serialize (a: Type) extends ToString a where
  to_bytes: a -> ByteArray
  from_bytes: ByteArray -> Except String a
\end{lstlisting}
By implementing this TypeClass a Type can converted to, and from a ByteArray, enabling it to be sent over the network.

\section{Distributed Values}
When computing with values in a global choreographic description it is crucial to differtiate between ``normal'' and distributed values. Since the choreography projects to different executable programs, distributed values can only live at a single location at a time. The authors of HasChor used Language extensions to integrate the location of a value into the type system. This is important to statically distinguish between a Value that lives on a location l1 and a value on l2 where l1 != l2.
Lean's dependent Typesystem however provides more flexibility and lets express the same dependent type without any language extensions or third party librarys like follows:
\begin{lstlisting}[language=lean]
inductive LocVal (α: Type) (loc: String) where
| Wrap: α -> LocVal α loc
| Empty: LocVal α loc
\end{lstlisting}
Here \emph{LocVal.Wrap} elements are representing Values at the Location \emph{loc} where LocVal simply holds a Value of a given type \emph{ alpha }.
The \emph{Empty} Option represents the abscence of an actual \emph{alpha} Value for all locations other than \emph{loc}. This is important in the endpoint projection process. We present two functions to go from and to a LocVal from a given Value of any Type alpha:

\begin{lstlisting}[language=lean]
def wrap {a} (v:a) (l: String): a @ l:=
  LocVal.Wrap v

def unwrap (lv: a @ l) (ex: notEmpty lv):  a := match lv with
| LocVal.Wrap v =>  v

\end{lstlisting}

\section{Effects and Free Monads}
In this section i will describe the effect System that i implemented in Lean

\begin{lstlisting}[language=lean]
inductive Freer (Eff:Type u -> Type v) (α:Type u) where
| Do: Eff β -> (β -> Freer Eff α) -> Freer Eff α
| Return: α -> Freer Eff α
\end{lstlisting}

\begin{lstlisting}[language=lean]
inductive Freer (Eff:Type u -> Type v) (α:Type u) where
| Do: Eff β -> (β -> Freer Eff α) -> Freer Eff α
| Return: α -> Freer Eff α
\end{lstlisting}
\begin{lstlisting}[language=lean]
inductive SumEff (eff1 eff2: Type → Type 1) (α:Type):  Type 1 where
| eff1: eff1 α → SumEff eff1 eff2 α
| eff2: eff2 α → SumEff eff1 eff2 α
\end{lstlisting}

\begin{lstlisting}[language=lean]

inductive EmptyEff: Type → Type 1
\end{lstlisting}

\begin{lstlisting}[language=lean]
\end{lstlisting}
