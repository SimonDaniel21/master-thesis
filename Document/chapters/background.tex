\chapter{Background}
\label{ch:abstract}
\section{Dictionary}

(clarify the use of Agent, nodes, locations and be consistent throughout the thesis.)
Literature uses different kinds of naming conventions for talking about communication paricipants, sometimes to express a slightly different intent that share semantically the same properties. I will stick to location throughout my work, in other work you might read terms like nodes, parties, Agents. The paper also presents several extensions (... maybe add whats important)

\subsection{deadlocks}
A deadlock occurs when a computer prgoram ist not able to progress any further. This is usally considered as undesired behaviour, even if the program was not able to finish its task successfully there still remain unused processes on the CPU that might not be able to release aquired resources any more to the System. On large scale Distributed Systems this can lead to potentially large expenses for the hardware operator. An Textbook example would be set up by 2 Processes both performing a blocking send operation other the network but never being able to reach the complementary receive.
\subsection{Choreography}
A Choreography is program specification with first party support for distributed computation. Usual imperative or functional PLs target a single CPU by default to run on, meaning the compiler will only output a single executable prgoram file. Approaches to Multiparty programming might be to branch inside the Programm depending on the executing Node/location ID or write different programs from the ground up.
By using a common choreographic specification, however, programmers gain a few crucial benefits. The System behaviour can be written in one common place, the intent of and order of communication can be expressed more intuively and it can be easier to argue about safety guarantees as we see later on.

\subsection{higher order Choreography}
Higher order Choreos are Choreos that can take other Choreos as an Argument. This can be very handy and be thought of subprotocols. An example would be a Choreo where you act as a buyer that wants to buy books from a seller. Additionaly you have a friend and are negotiating with him how much money he wants to lend you. The negotiation choreo between you and your friend can now be taken as an argument for the book buying Choreo. The benefit is that details of the negotiation arent neccessary anymore in a static context, but can be supplied at runtime!

(wenn ich es habe kann ich hier ja mein Beispiel rein bringen)


\subsection{Knowledge of Choice}

Whenever a party inside a Choreography branches on some kind of runtime condition other parties might have to be informed of that branching choice. this does not allways have to be the case, but only if a second party's communication pattern depends on the branch decision it has to aquire the 'Knowledge of Choice' through a notification of some kind.

\subsection{Session Types}
or Program Types describe the communication patterns and can be thought of as protocols. In my Paper I differntiate between global and local (session) Types. By Global i mean the global view over \emph{all} locations and local being the view of a single actor/location. The Global Type describes the protocol of the Multiparty program, always specifiing sender and receiver for communication operations. In contrast a local type only cares about one side, as for send operations the sender is implicetely set to the location of the local type and vice versa for receiving. In a Multi Party prgoram with more than 2 participants, a local type may ignore all communication between locations that does not include itself.

globalType ->
\newline | a -> b: dataType. globalType
\newline | end

dataType ->
string
\newline | number
\newline | globalType

\section{Sessions and Session Types:
an Overview}
Session Types take an important role for Choreos and describe the interaction of two (binary) or more (multi party) locations at communication level. We differentiate between \textbf{Global Session Types} that describe the sequence of directed message exchange for a session, and \textbf{Local Session Types}, which reflect the same Protocol but from one locations's perspective. The projection from a global session type to a local ST is called \textbf{End Point Projection} and basicallay translates all sending operations to send operations if location being projected to is sending, or receive operations if is receiving.

\section{MultiParty Session Types}


Essential Session Type Syntax introduced by K. Honda in the 1990

\begin{grammar}

<T> ::= end
	\alt !S.S' -- Send
	\alt ?S.S' -- Receive

\end{grammar}

\begin{grammar}
<G> ::= end
	\alt $\mu t. G$
	\alt t
	\alt $ p \rightarrow q: \{l_i(S_i).G_i\}_{i \in I}$

\end{grammar}


Syntax of Introduction to MPST

\begin{grammar}

<S> ::= nat
	\alt int
	\alt bool

\end{grammar}

\begin{grammar}

<T> ::= end
	\alt $ \&_{i \in I} p?l_i(S_i).T_i$
	\alt $\oplus _{i \in I} q!l_i(S_i).T_i$
	\alt $\mu t.T$
	\alt t

\end{grammar}

Syntax of Mira / TU Darmstadt
extends the previous Global Type Syntax by the following:
\begin{grammar}

<G> ::= [b]G
	\alt G|G
	\alt G+G
	\alt $\prod x:I.G$
	\alt G e

\end{grammar}

Extension to Local Types
\begin{grammar}

<T> ::= [b]T
	\alt T+T
	\alt $\prod x:I.T$
	\alt T e

\end{grammar}

Global Type Implementation in Lean4

\begin{lstlisting}[language=lean]
inductive P where
  | IF 			: located Exp -> P -> P -> P
  | SEND_RECV   : located Exp -> located Variable -> P -> P
  | COMPUTE (v: Variable) (e: Exp) (a: Location) :   P -> P
  | END     	: Exp -> Location -> P
\end{lstlisting}

\section{HasChor: Functional Choreographic Programming for All
(Functional Pearl)}
this paper is about Choreographic programming and an implementation for the Haskell Language. Choreographies are implemented as a Library for use with Haskell and expressed as Computational monads. Might be helpful for own Implementations in Lean to look at their Design Choices for Language Design. Special remarks are on the \textbf{higher order} capabilities, meaning Choreographies can take other Choreos as a parameter as some kind of sub-protocol, as well as \textbf{location polymorphism}. Location polymorphism here means the runtime substitution of locations.

\section{Modular Compilation for Higher-Order Functional
Choreographies}
Higher order Choreographies make it non trivial to check which locations are involved in the Choreography. For example if Choreo C depends on Choreo K, the participants of C are only known after K is instantiated. This poses problems for static checks and the EPP. The paper proposes approaches to extend the lambda calcus to achieve a modular applications of an EPP (did not fully understand alot)

\section{On the Monitorability of Session Types, in Theory
and Practice}
about runtime checking and monitoring of communication but very long

\section{Multiparty Languages: The Choreographic and
Multitier Cases}

this work presents the two programming paradigms Choreographic programming and Multitier. Multitier being programm descriptions that specify the location of operations instead of explicit communication. While both approaches have different roots and went through different development, mainly because both workgroups rarely mix or push collective results, there still is a fundamental linkage between both. This similiaritys could lead both camps to \textbf{cross-fertilisation} that benefits both. This statement is backed by the comparison of two stripped down versions of an Choreo PL and a Multitier one.

\section{Certified Automatic Repair of Uncompilable Protocols}
There are Choreos that are not (directly) projectable to local Programs / types. Branching adds the challenges for the session, since continuation of a location protocal might depend on some choice that leads to different executions of two or more sub Protocols. This issue can be fixed by informing other Party members of branching choices that a location might does, called \textbf{knowledge of choice}. The paper also describes more clever ways of propagating choices, since not all choices are relevant to all locations and choices can be transitively propageted for example. The Automated Process is called \textbf{Amendment} or \textbf{repair}.
