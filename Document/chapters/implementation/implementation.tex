\chapter{Implementation}
\label{ch:implementation}

this chapter presents the Lean Code of my library implementation in detail. It also compares it to different implementations and discusses the design choices being made.
\par
throughout the code im using the following variables for the respective context.
here is a table of symbols and how i use them in this chapters code

$\mu$ : Type that can be transfered over the network, has an Serialize instance
$\delta$: Choreos are parameterized by the Type of locations called $\delta$
$\alpha$,$\beta$: Types
ep: short for 'endpoint'. This is a value of type $\delta$ that represents the location a local program is meant to be run on

Lean allows you to specify \"variables\", not to be confused with global variables as in global state from other PLs.
\input{chapters/implementation/variables}
Here, even though $\mu$ does not provide a Serialize instance explictely but it is implicetely inserted through the variable statement. This allows to omit the Serialize instances in my implementation code.
%\section{Prgram Syntax}
%
% Choreo (Multiparty Program) P -> if E then P else P endif P
% \newline| send_receive 		:v@l <= v@l2
% \newline| compute      		: v@l <= E@l
% \newline| choreo 			: v@l <= CHOREO with mapping P END_CHOREO P
% \newline| end 				: v@l
%
% Expression E -> Variable: v
% \newline| CONSTANT : c
% \newline| PLUS     : (E+E)
% \newline| DIVIDE   : (E/E)
% \newline| Function -> f(E)
%
% v sind Variablennamen (Strings) und l Location Namen (Strings)
%
% \begin{grammar}
% <Choreo> ::= <ident> ‘=’ <expr>
% \alt ‘for’ <ident> ‘=’ <expr> ‘to’ <expr> ‘do’ <statement>
% \alt ‘{’ <stat-list> ‘}’
% \alt <empty>
% <stat-list> ::= <statement> ‘;’ <stat-list> | <statement>
% \end{grammar}
%
%
% \begin{grammar}
% <Choreo> ::= <ident> ‘=’ <expr>
% \alt ‘for’ <ident> ‘=’ <expr> ‘to’ <expr> ‘do’ <statement>
% \alt ‘{’ <stat-list> ‘}’
% \alt <empty>
% <stat-list> ::= <statement> ‘;’ <stat-list> | <statement>
% \end{grammar}

\section{Networking in Lean4}
Lean4's standard Library provides IO operations for exchanging values between multiple Threads. While this would suffice to test the functionality of running Choreographies on a single machine, it is much more desirable to be able to split the Choreography into actual seperate programs that may run on different machines. To accomplish this I decided to implement message exchanging by Sockets.
While some PLs like Java provide a Language embedded implementation of Sockets, or other well established Languages like Haskell provide mature Librarays for a Socket API, Lean has a much younger ecosystem that seems less feature rich. The Solution i chose is the relatively new Lean4 library 'sockets for Lean 4' by Henrik Böving (TODO in Quellen reinpacken) which is hosted at https://github.com/hargoniX/socket.lean under the MIT License. It servers as a wrapper around the platform specific 'winsock.h' Windows, and the 'sys/socket.h' Unix C-librarys while providing a native Lean interface. At the time of working on this thesis the \emph{Sockets} did not work with the, at that time, newest Version of Lean 4.6.0. Thanks to them they updated an underlying library (https://github.com/tydeu/lean4-alloy) and accepted my Merge Request with the version bump \cite{test}.
\par
To abstract away the Socket setup code in my local programs i decided to reopen a new socket for every communication operation in the Choreography for simplicity

\input{chapters/implementation/netsend}

similiarly to the sock.connect operation, the 'receive' function will bind an listen to a socket with the corresponding addres. For convenience a 'broadcast' function is also available, that takes an 'List address' instead of a single address and sends msg to all addresses in the List.

Serialize is a simple TypeClass that provides the following two functions:
\input{chapters/implementation/serialize}
By implementing the Serialize class, a Type can converted to, and from a ByteArray, enabling it to be sent over the network. Note that \lstinline!to_bytes! is a partial function that may not return a conversion of that type. Not every ByteArray must be convertible into a type. A ByteArray created by the to_bytes function however should always be able to convert back into the initial value by the from_bytes function. Lean lets you add this condition as an additional class Field like
\input{chapters/implementation/serializecorrectness}
(with an addtional assumption that from_bytes is no Exception). I omitted this proof in my implementation since writing such rigorous proofs for Serialize instances like Lists would be out of scope of this thesis, as im not trying to implement a perfect Serialization Framework for Lean.

\subsection{Network Effects}
\input{chapters/implementation/neteff}

\subsection{Persitant Connections}

\input{chapters/implementation/channel}

\section{Locations}

explain the chosen Type for location and why it differs from HasChor, pros cons

\section{Distributed Values}
When computing with values in a global choreographic description it is crucial to differtiate between ``normal'' and distributed values. Since the choreography projects to different executable programs, distributed values can only live at a single location at a time. The authors of HasChor used Language extensions to integrate the location of a value into the type system. This is important to statically distinguish between a Value that lives on a location l1 and a value on l2 where l1 != l2.
Lean's dependent Typesystem however provides more flexibility and lets express the same dependent type without any language extensions or third party librarys like follows:
\input{chapters/implementation/gval-haschor}
\input{chapters/implementation/gval}
Here \emph{LocVal.Wrap} elements are representing Values at the Location \emph{loc} where LocVal simply holds a Value of a given type \emph{ alpha }.
The \emph{Empty} Option represents the abscence of an actual \emph{alpha} Value for all locations other than \emph{loc}. This is important in the endpoint projection process. We present two functions to go from and to a LocVal from a given Value of any Type alpha:

\input{chapters/implementation/wrap}

\section{Coproducts and Free Monads}
Lean4 is a functional programming Language by nature, but we can still write effectful programs. Like in Haskell and other functional programming languages this is done with Monads. The special Monad Type that lets us run effects is called \emph{IO}. IO allows the program to effect the world outside the pure function, by for example printing text to the terminal, generating random numbers, writing files, spawning processes and many more. This broad variety of basically any possible effects in a IO program makes it harder to argue about about the programs.
IO is therefore called a 'sin bin' \cite{datatypes-a-la-carte} of effects. Ecspecially in the realm of distributed programs and web there is a even bigger appeal to be able to concisely state the effect capabilities of a program. Usally there are 2 or more roles involved with different IO requirements. For example a web application where the user needs to run some kind of user interface locallay, and webserver wich accesses a sql database to feed data to the user.
Neither the user has any buisness to manipulate a database, nor has the server any buisness to graphically display a UI. To make this seperation of concerns explicit in code I made use of the concept of Free Monads \cite{datatypes-a-la-carte}
In this section i will describe Free Monads and coproducts, my implementation in Lean and show how they can be used
\input{chapters/implementation/freer}
This inductive Type \emph{Freer} is parameterized by \emph{Eff} which is a function that takes a type and returns a type. \emph{Eff} is short for 'effect' and determines the type of a effects the freer monad can capture. There are two possible Values of Freer: either a pure value (Return, l.3) of the parameterized type $\alpha$ or an inpure Effect followed by a continuation of this effect (DO, l.2).
\lstinline!Type u -> Type v! is the type of all monads.
To give an better intuition about Freer, lets look at \lstinline!Freer IO! for example. As IO is a monad it also has the correct type. \lstinline!Freer.Do! now has a very intuitive meaning of: a program that produces a value of type beta and a continuation that depends on such a result beta.
Freer itself has also Monad instance that also is quite straight forward.
\input{chapters/implementation/freer-monad}
To wrap an pure value into the Freer Monad \lstinline!Freer.Return! is used. The bind works by appliing the continuation to the pure value of a \lstinline!Freer.Return!, or recursively %TODO nachdenken
you can think of it as a sequence.

The Freer Monad is only an abstract sequence of effects as an algebraic structure, but we also want to execute this as IO programs for example. To achieve this you normaly define 'run' or 'interpretation' functions that interpret the Freer monad in terms of another monad. Lean already provides for this sort of 'interpretation as a monad' a technique called MonadLifting. This can automatically interpret Monads (or just Type -> Type without a Monad instance) as an other monad and you do not need to be explicit about it.
