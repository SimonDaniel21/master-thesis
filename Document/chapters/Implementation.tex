\chapter{Implementation}
\label{ch:implementation}


\section{Prgram Syntax}

Choreo (Multiparty Program) P -> if E then P else P endif P
\newline| send_receive 		:v@l <= v@l2
\newline| compute      		: v@l <= E@l
\newline| choreo 			: v@l <= CHOREO with mapping P END_CHOREO P
\newline| end 				: v@l

Expression E -> Variable: v
\newline| CONSTANT : c
\newline| PLUS     : (E+E)
\newline| DIVIDE   : (E/E)
\newline| Function -> f(E)

v sind Variablennamen (Strings) und l Location Namen (Strings)

\begin{grammar}
<Choreo> ::= <ident> ‘=’ <expr>
\alt ‘for’ <ident> ‘=’ <expr> ‘to’ <expr> ‘do’ <statement>
\alt ‘{’ <stat-list> ‘}’
\alt <empty>
<stat-list> ::= <statement> ‘;’ <stat-list> | <statement>
\end{grammar}


\begin{grammar}
<Choreo> ::= <ident> ‘=’ <expr>
\alt ‘for’ <ident> ‘=’ <expr> ‘to’ <expr> ‘do’ <statement>
\alt ‘{’ <stat-list> ‘}’
\alt <empty>
<stat-list> ::= <statement> ‘;’ <stat-list> | <statement>
\end{grammar}

\section{Networking in Lean4}
Lean4's standard Library provides IO operations for exchanging values between multiple Threads. While this would suffice to test the functionality of running Choreographies on a single machine, it is much more desirable to be able to split the Choreography into actual seperate programs that may run on different machines. To accomplish this I decided to implement message exchanging by Sockets.
While some PLs like Java provide a Language embedded implementation of Sockets, or other well established Languages like Haskell provide mature Librarays for a Socket API, Lean has a much younger ecosystem that seems less feature rich. The Solution i chose is the relatively new Lean4 library 'sockets for Lean 4' by Henrik Böving (TODO in Quellen reinpacken) which is hosted at https://github.com/hargoniX/socket.lean under the MIT License. It servers as a wrapper around the platform specific 'winsock.h' Windows, and the 'sys/socket.h' Unix C-librarys while providing a native Lean interface. At the time of working on this thesis the \emph{Sockets} did not work with the, at that time, newest Version of Lean 4.6.0. Thanks to them they updated an underlying library (https://github.com/tydeu/lean4-alloy) and accepted my Merge Request with the version bump \cite{test}.
\par
To abstract away the Socket setup code in my local programs i decided to reopen a new socket for every communication operation in the Choreography for simplicity

\begin{lstlisting}[language=lean]
def address.send (a: address) (msg: t) [Serialize t]: IO Unit := do
  let bytes := Serialize.to_bytes msg
  let sock ← Socket.mk .inet .stream
  sock.connect a
  let sz ← sock.send bytes
  sock.close
\end{lstlisting}

similiarly to the sock.connect operation, the 'receive' function will bind an listen to a socket with the corresponding addres. For convenience a 'broadcast' function is also available, that takes an 'List address' instead of a single address and sends msg to all addresses in the List.
\newline
Serialize is a simple TypeClass that provides the following two functions:
\begin{lstlisting}[language=lean]
class Serialize (μ: Type) μ where
  to_bytes: μ -> ByteArray
  from_bytes: ByteArray -> Except String μ
\end{lstlisting}
By implementing the Serialize class, a Type can converted to, and from a ByteArray, enabling it to be sent over the network. Note that from_bytes is a partial function that may not return a conversion of that type. Not every ByteArray must be convertible into a type. A ByteArray created by the to_bytes function however should always be able to convert back into the initial value by the from_bytes function. Lean lets you add this condition as an additional class Field like
\begin{lstlisting}[language=lean]
 correct: ∀ (v: μ), (from_bytes (to_bytes v)) = v
\end{lstlisting}
(with an addtional assumption that from_bytes is no Exception). I omitted this proof in my implementation since writing such rigorous proofs for Serialize instances like Lists would be out of scope of this thesis, as im not trying to implement a perfect Serialization Framework for Lean.

\subsection{Network Effects}

\begin{lstlisting}[language=lean]
inductive NetEff (ep: δ): Type -> Type 1
| send {μ: Type} [Serialize μ] : (r:δ) -> (r ≠ ep) -> μ -> NetEff ep Unit
| recv : (r:δ) -> (r ≠ ep) ->  (μ: Type) -> [Serialize μ] -> NetEff ep μ
\end{lstlisting}
\subsection{Persitant Connections}

\begin{lstlisting}[language=lean]
structure SockChannel (sender receiver ep: δ ) where
  recv_sock: GVal receiver ep Socket
  send_sock: GVal sender ep Socket
\end{lstlisting}

\section{Distributed Values}
When computing with values in a global choreographic description it is crucial to differtiate between ``normal'' and distributed values. Since the choreography projects to different executable programs, distributed values can only live at a single location at a time. The authors of HasChor used Language extensions to integrate the location of a value into the type system. This is important to statically distinguish between a Value that lives on a location l1 and a value on l2 where l1 != l2.
Lean's dependent Typesystem however provides more flexibility and lets express the same dependent type without any language extensions or third party librarys like follows:
\begin{lstlisting}[language=lean]
inductive LocVal (α: Type) (loc: String) where
| Wrap: α -> LocVal α loc
| Empty: LocVal α loc
\end{lstlisting}
Here \emph{LocVal.Wrap} elements are representing Values at the Location \emph{loc} where LocVal simply holds a Value of a given type \emph{ alpha }.
The \emph{Empty} Option represents the abscence of an actual \emph{alpha} Value for all locations other than \emph{loc}. This is important in the endpoint projection process. We present two functions to go from and to a LocVal from a given Value of any Type alpha:

\begin{lstlisting}[language=lean]
def wrap {a} (v:a) (l: String): a @ l:=
  LocVal.Wrap v

def unwrap (lv: a @ l) (ex: notEmpty lv):  a := match lv with
| LocVal.Wrap v =>  v

\end{lstlisting}

\section{Effects and Free Monads}
In this section i will describe the effect System that i implemented in Lean

\begin{lstlisting}[language=lean]
inductive Freer (Eff:Type u -> Type v) (α:Type u) where
| Do: Eff β -> (β -> Freer Eff α) -> Freer Eff α
| Return: α -> Freer Eff α
\end{lstlisting}


\begin{lstlisting}[language=lean]
inductive EmptyEff: Type → Type 1
\end{lstlisting}

\begin{lstlisting}[language=lean]
\end{lstlisting}


\section{Examples}

This Section presents four choreographic programs, to demonstrate how choreographies can be written in Lean using the chorlean library. The first example \ref{ss:silent} shows a very basic communication scheme. In the \ref{ss:book} example a already more complex protocol is presented to highlight higher Level Choreographies aswell as Location Polymorphism. \ref{ss:sso} Shows an application of a simple cryptographic protocol for a SSO service and the last example \ref{ss:merge} showcases a compute heavy application that balances compute load of a sorting algorithm across a set of  nodes.

\subsection{silent post}
\label{ss:silent}
This first Distributed protocol is kept simple to demonstrate some of the features(TODO einen richtigen Satz formulieren).
Three Participants, Alice, bob and eve take part in this protocol. The Scheme is that alice prompts an text input from the user, Then passes this input arround in a circle through bob and eve. Both bob and eve perfom local modifications of the message in the spirit of the silent post game.

\begin{lstlisting}[language=lean]
def silent_post (ep:Location): Choreo ep Unit:= do
  let input <- locally alice do
    info "enter a message"
    return <- readString

  let msg: String @ bob <- input ~> bob
  let msg <- locally bob do return [(⤉msg), "bob"]

  let msg <- msg ~> eve
  let msg <- locally eve do return (⤉msg).concat "eve"

  let msg <- send_recv msg alice
  locally alice do info s!"finished with string from eve: {msg}"
\end{lstlisting}
As the Type of a Choreo depends on the endpoint it is projected to, the silent_post function carries an endpoint as a argument. Also notice the \emph{@} notation, that is an abbreviation for an \emph{GVal} Type with implicit endpoint. This notation works inside a Choreo as the endpoint of GVal's resulting from a communication or local operation is allways the endpoint the choreography is parameterized with.
As discussed in --TODO-- the locally functions lets uns define a Freer-Monad with all locally available effects. For Silent post, those local Effect Signatures are defined as
\begin{lstlisting}[language=lean]
instance sig: LocSig Location where
  sig x := match x with
    | alice =>  CmdInputEff ⨳ LogEff
    | bob =>  LogEff
    | eve => LogEff
\end{lstlisting}
such that every location is allowed to perform a logging effect \emph{LogEff} and additionally alice has access to CmdInputEff, which allow to prompt a String from a User in the command line.


\subsection{book seller}
\label{ss:book}

\begin{lstlisting}[language=lean]
def book_seller (negotiate: negT buyer ep)
  : Choreo ep (Option (String @ buyer # ep)) := do

  let budget <- locally buyer do get_budget
  let title <- locally buyer do get_title

  let title' <- (title ~> seller)
  let price <- locally seller do lookup_price (⤉title')
  let price <- price ~> buyer

  locally seller do info s!"got book title: {⤉title'}"

  locally buyer do info s!"the price is {⤉price}, negotiate with friend"

  let d <- negotiate budget price -- calls another choreo :)

  branch d fun
  | true => do
    let date <- locally seller do deliveryDate
    let date <- date ~> buyer
    return some date
  | false => do
    locally seller do warning s!"the customer declined the purchase"
    locally buyer do error s!"{⤉title} has a price of {⤉price} exceeding your budget of {⤉budget}!"
    return none

\end{lstlisting}

\subsection{sso authentication}
\label{ss:sso}

\begin{lstlisting}[language=lean]
structure Credentials where
  username: String
  password: String

def authenticate (ep:Location) (creds: Credentials @ client # ep):
  Choreo ep (Option ((String @ client # ep) × (String @ service # ep))):= do

  let pw <- locally client do return (⤉creds).password
  locally service do info "hello service"
  let username <- locally client do return (⤉creds).username
  let username' <- username ~> IP
  let salt <- locally IP do return add_salt (⤉username')
  let salt <- salt ~> client
  let hash <- locally client do return (calcHash (⤉salt) (⤉pw))
  let hash <- hash ~> IP
  let valid <- locally IP do check_hash (⤉hash)

  branch valid fun
  | true => do
    let token <- locally IP do IPEff.createToken
    let token_c <- token ~> client
    let token_s <- token ~> service
    return (token_c, token_s)
  | false =>
    return none
\end{lstlisting}

\subsection{mergesort}
\label{ss:merge}

\begin{lstlisting}[language=lean]
def silent_post (ep:Location): Choreo ep Unit:= do
  let input <- locally alice do
    info "enter a message"
    return <- readString

  let msg: String @ bob <- input ~> bob
  let msg <- locally bob do return [(⤉msg), "bob"]

  let msg <- msg ~> eve
  let msg <- locally eve do return (⤉msg).concat "eve"

  let msg <- send_recv msg alice
  locally alice do info s!"finished with string from eve: {msg}"
\end{lstlisting}
